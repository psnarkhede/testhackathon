# Developer Guide

## Project Overview

This project is a TypeScript-based backend application designed with modularity and scalability in mind. It leverages a layered architecture to manage incoming requests efficiently, including clearly defined responsibilities across controllers, services, and data transfer objects (DTOs). The primary focus is on creating RESTful APIs with validation and clean separation of concerns.

## Setup & Installation

- **Clone the repository:**

  ```bash
  git clone <repository-url>
  cd <repository-directory>
  ```

- **Install dependencies:**

  ```bash
  npm install
  ```

- **Run the application locally in development mode:**

  ```bash
  npm run start:dev
  ```

- **Environment Variables:**

  If your project requires environment variables, ensure to create a `.env` file in the root directory with necessary keys. Typical environment variables might include database URLs, API keys, or ports. Check the project root or configuration files for `.env.example` or documentation on required environment variables.

## Architecture & Folder Structure

- **Main folders:**

  - `controllers`: Handle incoming HTTP requests, route them to appropriate services.
  - `services`: Business logic and interaction with data sources.
  - `dto`: Data Transfer Objects used for validation and shaping request/response data.
  - `main.ts`: Application entry point, sets up the server.

- **Request flow:**

  1. **Controller** receives an HTTP request, performs basic validation/routing.
  2. Controller calls the **Service** layer to process business logic.
  3. The **Service** may use **DTOs** for input validation and output shaping.
  4. Finally, a response is returned to the client.

---

## Files

### `app.controller.ts`

```typescript
import { Controller, Get, Param, Post, Body } from '@nestjs/common';
import { AppService } from './app.service';
import { CreateUserDto } from './dto/create-user.dto';

@Controller('users')
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getAllUsers() {
    return this.appService.findAllUsers();
  }

  @Get(':id')
  getUserById(@Param('id') id: string) {
    return this.appService.findUserById(id);
  }

  @Post()
  createUser(@Body() createUserDto: CreateUserDto) {
    return this.appService.createUser(createUserDto);
  }
}
```

**Path**: `src/app.controller.ts`

### Endpoints

- `GET /users`  
  Retrieves a list of all users.

- `GET /users/:id`  
  Retrieves details of a user by ID.

- `POST /users`  
  Creates a new user with the data provided in the request body.

---

### `app.service.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';

interface User {
  id: string;
  name: string;
  email: string;
}

@Injectable()
export class AppService {
  private users: User[] = [];

  findAllUsers(): User[] {
    return this.users;
  }

  findUserById(id: string): User | undefined {
    return this.users.find(user => user.id === id);
  }

  createUser(createUserDto: CreateUserDto): User {
    const newUser = {
      id: (this.users.length + 1).toString(),
      ...createUserDto,
    };
    this.users.push(newUser);
    return newUser;
  }
}
```

**Path**: `src/app.service.ts`

---

### `dto/create-user.dto.ts`

```typescript
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class CreateUserDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsEmail()
  email: string;
}
```

**Path**: `src/dto/create-user.dto.ts`

### DTO Fields

- `name: string`  
  - Must be a string  
  - Must not be empty  

- `email: string`  
  - Must be a valid email address  

---

### `main.ts`

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();
```

**Path**: `src/main.ts`

---

### `app.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

**Path**: `src/app.module.ts`

---

## Contribution Guide

- **Coding Conventions:**
  - Follow TypeScript best practices.
  - Use consistent naming conventions (camelCase for variables and methods, PascalCase for classes).
  - Maintain separation of concerns: Controllers for routing, Services for business logic, DTOs for validation.
  - Write clear, concise comments and JSDoc where necessary.
  - Validate inputs using class-validator decorators on DTOs.

- **Adding New Features:**
  1. Create a new DTO in the `dto` folder if input validation is needed.
  2. Add business logic in the corresponding service file.
  3. Expose endpoints through a controller.
  4. Update or add unit tests to cover the new functionalities.
  5. Follow the existing folder and file structure for consistency.

- **Pull Requests:**
  - Ensure your branch is up-to-date with the `main` branch.
  - Include clear commit messages.
  - Write or update tests.
  - Perform manual testing of API endpoints when relevant.
  - Request reviews and address feedback promptly.

---

## Testing

- **Running Unit and Integration Tests:**

  ```bash
  npm run test
  ```

- Tests should cover services, controllers, and DTO validation logic.
- Use mocks and stubs for isolated unit tests.
- Integration tests should verify end-to-end request-response flows.
- Add tests for any new features or critical bug fixes.

---

By following the above guide, you can effectively understand, contribute, and extend the functionality of the project while maintaining code quality and consistency.